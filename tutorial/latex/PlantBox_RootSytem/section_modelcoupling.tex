\newpage
\section{Coupling to numerical models}

As bottom up model in CPlantBox no water movement or solute transport models are computed per default. The idea is to make it easy to link the root growth model to any numerical models. This is achieved by member functions that make it easy (a) to obtain a numerical grid from the root system, and (b) to offer utility functions to map root segments to an underlying soil grid. 

In this section we consider a static root system. The additional steps that are needed for a developing root system (i.e. a changing geometry) are explained in the next section. 

\subsection{Mapping between root segments and an underlying soil}

The classes MappedSegments and MappedRootSystem that are defined in MappedOrganism.h manage the coupling between the root system and external models or solvers. 

The RootSystem class stores the nodes of each root per root in the class Root. This convenient for simulating the root development, but not suitable for coupling to numerical models. Commonly, numerical models will need the nodes as sequential list (obtained by RootSystem::getNodes) and the information on how they are connected. Additionally, some information on the segments like radius or root type is needed. Furthermore, when coupling to a soil model, we need information in which soil cell the segment is located, and vice versa, we need information which segments are located within a specific soil cell. 

The class MappedSegments helps to manage all that, and offers the data structure for sequential nodes, connection data as segments, and the most commonly needed data such as creation time of the node, and radius or type per segment. Additionally, it has two hash maps linking segments to cells, and cells to list of segments.

MappedRootSystem is derived from MappedSegments and RootSystem, i.e. can be used exact the same way as the RootSystem class, but keeps track of the lists, and (optionally) the mapping between soil and root system.

To demonstrate basic functionality we will map a root system to a soil rectangular soil grid. 

\lstinputlisting[firstline=1, language=Python, caption=Example 6a]{../../examples/python/example6a_mapping.py}
\begin{itemize}

\item[8-12] Creation of a small root system, ten days simulation of Anagallis. Instead of the class RootSystem MappedRootSystem is used (L8). MappedRootSystem is a specialisation of the 'normal' RootSystem class and can be used in exactly the same way. 

\item[16-19] We choose a small soil domain, where some roots are not inside. Calling MappedRootSystem::setRectangularGrid first cuts segments at the cell faces, and then maps the resulting segments to a soil index (creates the maps MappedRootSystem::seg2cell, and MappedRootSystem::cell2seg).

\item[22-28] Next we create an array $x$ containing the soil indices for each segment. We use the hash map (a Python dictionary) MappedRootSystem::seg2cell to obtain the linear index of the cell, where the segment mid point is located.

\item[31-37] To demonstrate how to retrieve all segments that lie within a given cell we output the segments at the cell located around the postion [0,0,-7]. In L31 we retrieve the cell index for that position. L34 and L35 print out the segment indices. Note that the map will have no entry for a given cell, if no segments are located in the cell. 

\item[43-48] To visualize the soil cell indices, we first create a SegmentAnalyser class. The class MappedRootSystem is derived from a RootSystem and MappedSegments. If we create a SegmentAnalyser class directly from $rs$ (L40) MappedRootSystem will be considered as RootSystem, and the resulting class will contain the original segments before cutting at the cell boundaries. The function MappedRootSystem::mappedSegments (L41) will return a reference to $rs$ but with the type MappedSegments. In this way the SegmentAnalyser class will be created with the cut segments. Next, in L42 we add the indices as data to the SegmentAnalyser class. L43, L44 produces the VTK plot, but rendering is started at a later point, since we also want to visualize the underlying soil grid.

\item[51-53]  L47 creaetes the mesh for vizualisation, L48 creates the VTK plot, and L49 starts the rendering window, rendering both, root system and underlying soil. Press 'y', 'x', and 'z' to obtain axis aligned views of the root system and soil grid.

\end{itemize}

More, generally, when coupling to an external solver like DuMux, we need to set the soil$\_$index function, that returns the cell index for a certain position. Addionally periodic soil domains are already implemented. Both coupling to DuMux and periodicity will be demonstrated in Section \ref{sec:dumux_coupling}.

Coupling to an unstructured grid is as simple as to a structured one. But the automatic cutting of segments to the cells is currently not implemented. That means that axial resolution should be small in order to keep the introduced error small.



\subsection{Water movement within the roots}

Sincewater movement within the roots is often needed it is implemented directly in CPlantBox (in the class XylemFlux). However, usage is optional, and any other transport code can be used (e.g. if solutes are considered). XylemFlux sets up the linear system, and the sparse linear system is then solved on the Python side using scipy (class XylemFluxPython defined in xylem$\_$flux.py).

The following example is based on benchmark M3.1 with constant conductivities, but not with a given root system, but with a simulated one.

\lstinputlisting[firstline=1, language=Python, caption=Example 6b]{../../examples/python/example6b_xylemflux.py}
\begin{itemize}

\item[11-15] All parameters that will be used later on.

\item[18-23] The root system (similar to last section). 

\item[26-31] The MappedRootSystem is wrapped with the XylemFluxPython class, which extends the XylemFlux class, which computes the xylem matric flux potential. L27, L28 sets the radial and axial conductivity. L29 retrievs the root system nodes for later visualisation. The pressure surrounding the the root system is either defined as pressure surrounding each root segment, or as soil cells, in which the root segments are located. L30, L31 sets a soil containing of one single cell with index 0. 

\item[34-36] XylemFluxPython defines solvers like solve$\_$dirichlet for Dirichlet boundary condition (predefined collar matric potential), solve$\_$neumann for Neumann boundary condition (predefined collar flux), and solve which switches between Dirichlet and Neumann at some critical pressure (the plant wilting point).
The agruments of solve$\_$dirichlet are the simulation time (to calculate age dependent conductivities), the root collar pressure head, the pressure around the root collar, the soil matric potential around the root segments or per soil cell, and a boolean value that decides if the potentials are given per soil cell (True) or per segments (False). The return value $rx$ contains the xylem matric potentials per segment. L35 calculates the fluxes into the soil (negative values mean into the root). The bool argument determines if we approximate the flux, or use the exact solution by Meunier et al. % todo ref
L36 determines the root collar flux.

\item[39-43] Plots the results.

\item[46-49] Creates the VTK plot, adding the soil matric potentials and fluxes. L49 picks either $rx$ or $fluxes$ for vizualisation, see Figure \ref{fig:xylemfluxa} and \ref{fig:xylemfluxb}.

\end{itemize}

It is possible to set conductivties per root type (see XylemFlux::setKr, and setKx), and root age dependent conductivities per root type using linear lookup tables (see XylemFlux::setKrTables, and setKxTables).

\begin{figure}
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.99\textwidth]{example6b.png}
\subcaption{Anagallis} \label{fig:xylemfluxa}
\end{subfigure}
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=0.99\textwidth]{example6b_2.png}
\subcaption{Maize} \label{fig:xylemfluxb}
\end{subfigure}
\caption{Calculated xylem matric potential (cm)} 
\end{figure}


\subsection{Coupling a static root system to DuMux} \label{sec:dumux_coupling}

Putting the last two sections together, we can easily set up an example, using the classic sink term in the soil model. (cite, sink) .

The next example mimics C12 benchmark (cite), but with a static simulated root system. The example must be run out of dumux-rosi (located in dumux-rosi/rosi$\_$benchmarking/python$\_$solver/coupled, otherwise the DuMux Python coupling is not available. 

\lstinputlisting[firstline=1, language=Python, caption=Example 6b]{../../examples/python/example6c_coupling.py}
\begin{itemize}

\item[3,4] Add paths for DuMux Python coupling (L3) and Python solvers (L4).

\item[5,6] The direct C++ part of the DuMux binding, and the Python wrapper class. 

\item[21-36] Defines a sinusoidal function for the collar boundary condition.

\item[39-48] ggg todo

\item[39-43] Plots the results.

\item[46-49] Creates the VTK plot

\end{itemize}



