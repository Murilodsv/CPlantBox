import sys
sys.path.append("../..")
import plantbox as pb

import math
import numpy as np
from scipy.optimize import minimize


def find_base_index(poly_indices, i):   
    """
    The index of the base, root this root with inde i is connected to
    
    @param poly_indices      the indices of all parent roots, usually properties["parent-poly"] 
    @param i                 the index of this polyline
     
    @return index of the base root this root i is part of 
    """
    if poly_indices[i] == -1:
        return i  
    else: 
        return find_base_index(poly_indices, poly_indices[i])


def find_order(poly_indices, i, o=1):   
    """
    The root order of the root with index i starting with 1
    
    @param poly_indices      the indices of all parent roots, usually properties["parent-poly"] 
    @param i                 the index of this polyline
    
    @return root order of root with index i 
    """
    if poly_indices[i] == -1:
        return o  
    else: 
        return find_order(poly_indices, poly_indices[i], o + 1)


def measurement_time(polylines, properties, functions, time):
    """
    Truncates the rsml data to a certain maximal time
    todo functions
    """
    pl, ps = [], {},
    fet = functions["emergence_time"]
    for i, p in enumerate(polylines):
        if fet[i][0] <= time:  # add
            p_ = []
            for j, node in enumerate(p):
                if fet[i][j] <= time:
                    p_.append(node)
            pl.append(p_)
            for k in properties.keys():
                ps.setdefault(k, []).append(properties[k][i])                                
    return pl, ps


def base_roots(polylines, properties):
    """
    return only the base roots
    """
    pp = properties["parent-poly"] 
    pl, ps = [], {}
    for i, p in enumerate(polylines):
        if pp[i] == -1:  # add if base root
            pl.append(p)
            for k in properties.keys():
                ps.setdefault(k, []).append(properties[k][i])
    return pl, ps           


def create_length(polylines, properties):
    """
    recalculate root lengths, and adds it to properties
    """
    properties["length"] = []
    for i, p in enumerate(polylines):
        l = 0.
        for j, n1 in enumerate(p[:-1]):
            n2 = p[j + 1]
            l += np.linalg.norm(np.array(n2) - np.array(n1))
        properties["length"].append(l)


def create_order(polylines, properties):
    """
    recalculate root orders, and adds it to properties
    """
    properties["order"] = []
    poly_indices = properties["parent-poly"]  # generated by read_rsml
    for i, p in enumerate(polylines):
        o = find_order(poly_indices, i)  
        properties["order"].append(o)


def negexp_growth(t, r, k):
    return k * (1 - np.exp(-(r / k) * t))


def target(r, k, length, times):
    """ target function for optimization for fit_taproot_r, fit_taproot_rk """ 
    sum = 0.
    for i, t in enumerate(times):
        sim_l = negexp_growth(t, r, k)
        sum_t = 0.
        if isinstance(length[i], float):
            sum_t += (sim_l - length[i]) ** 2
        else:
            for l in length[i]:            
                sum_t += (sim_l - l) ** 2            
            
        sum += np.sqrt(sum_t)
    return sum    

    
def fit_taproot_r(length, times, k):
    """ fits initial growth rate r, assumes maximal root lenght k as fixed (e.g. literature value) """
    assert(len(length) == len(times))
    f = lambda x0: target(x0, k, length, times)
    x0 = [1.]
    res = minimize(f, x0, method='Nelder-Mead', tol=1e-6)  # bounds and constraints are possible, but method dependent
    return res.x[0] 


def fit_taproot_rk(length, times):
    """ fits initial growth rate r, and maximal root lenght k """
    assert(len(length) == len(times))
    f = lambda x0: target(x0[0], x0[1], length, times)
    x0 = [5., 200]
    res = minimize(f, x0, method='Nelder-Mead', tol=1e-6)  # bounds and constraints are possible, but method dependent
    return res.x[0], res.x[1]


def target2(delay, times, numbers, i_n):
    """ target function for optimization for fit_number_of_roots""" 
    sum = 0.
    for i, t in enumerate(times):
        sim_n = i_n + t / delay  # missing round (continious seems easier to optimize)
        s = 0.
        for j in range(0, len(numbers[i])): 
            s += (numbers[i][j] - sim_n) ** 2
        sum += np.sqrt(s)     
    return sum


def fit_number_of_roots(times, numbers, initial_number):
    """ we fit the delay between emergence of seminals with, 
        number_of_roots = inital_number + round(t/delay)
    """
    assert(len(numbers) == len(times))
    f = lambda x0 : target2(x0, times, numbers, initial_number)
    x0 = [1.]  # days
    res = minimize(f, x0, method='Nelder-Mead', tol=1e-6)  # linear regression would be enough in this case
    return res.x[0]

# def fit_seminal_rk(length, times):
#     """ fits initial growth rate r, and maximal root lenght k """
#     assert(len(length.shape[0] == len(times))
#     f = lambda x0: target(x0[0], x0[1], length, times)
#     x0 = [5., 200]
#     res = minimize(f, x0, method='Nelder-Mead', tol=1e-6)  # bounds and constraints are possible, but method dependent
#     # print(x)
#     return res.x[0], res.x[1]


def estimate():
    pass
    
